<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pitch Shifter (Integrado)</title>
    <!-- Carga de Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        // Configuración de Tailwind para estilos y colores
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                    colors: {
                        'primary': '#10b981', // Verde esmeralda
                        'secondary': '#34d399',
                        'dark-bg': '#1f2937',
                        'card-bg': '#374151',
                    }
                }
            }
        }
    </script>
    <style>
        /* Estilos base para centrar la aplicación y darle un fondo oscuro */
        body {
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #1f2937;
        }
    </style>
</head>
<body>

    <div id="app" class="w-full max-w-sm p-6 m-4 bg-card-bg rounded-xl shadow-2xl text-white">

        <h1 class="text-3xl font-bold mb-4 text-center text-primary">Pitch Shifter Integrado</h1>
        <p class="text-sm text-gray-300 mb-6 text-center">Modifica la frecuencia (tono) sin alterar la velocidad (tempo) del audio.</p>

        <!-- Sección de carga de audio -->
        <div class="mb-6">
            <label for="audioFile" class="block text-sm font-medium mb-2 text-gray-200">
                Seleccionar Archivo de Música
            </label>
            <input type="file" id="audioFile" accept="audio/*" class="w-full text-sm text-gray-300
                file:mr-4 file:py-2 file:px-4
                file:rounded-lg file:border-0
                file:text-sm file:font-semibold
                file:bg-primary file:text-white
                hover:file:bg-emerald-600 cursor-pointer transition duration-150"
            />
        </div>

        <!-- Indicador de estado -->
        <p id="statusMessage" class="text-center text-sm mb-6 h-4 text-yellow-300 transition-opacity"></p>

        <!-- Botón de Reproducción/Parada -->
        <div class="mb-8 flex justify-center">
            <button id="toggleButton" disabled
                class="w-full py-3 px-6 text-lg font-semibold rounded-xl transition duration-300 ease-in-out
                       bg-gray-500 hover:bg-gray-600 text-white disabled:opacity-50 disabled:cursor-not-allowed shadow-lg"
                onclick="togglePlayback()">
                Cargar Audio Primero
            </button>
        </div>

        <!-- Control de Pitch Shifting (TONO/FRECUENCIA) -->
        <div class="mb-4">
            <label for="pitchSlider" class="block text-md font-semibold mb-3 text-gray-200">
                Ajuste de Frecuencia: <span id="currentPitch" class="font-bold text-primary">0.0 Semitonos (Original)</span>
            </label>
            <!-- Rango de -48 semitonos (cuatro octavas abajo) a +48 semitonos (cuatro octavas arriba) -->
            <input type="range" id="pitchSlider" min="-48" max="48" value="0" step="0.1" disabled
                oninput="updatePitch(this.value)"
                class="w-full h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer range-lg focus:outline-none focus:ring-2 focus:ring-primary focus:ring-offset-2 focus:ring-offset-card-bg"
            />
            <div class="flex justify-between text-xs mt-1 text-gray-400">
                <span>-48 Semitonos (Máximo Grave)</span>
                <span>+48 Semitonos (Máximo Agudo)</span>
            </div>
        </div>

        <!-- Descripción -->
        <p class="text-xs text-gray-400 mt-6 italic text-center">
            Algoritmo de Pitch Shifting simple integrado (sin dependencias externas). El paso es de 0.1 semitonos para mayor precisión.
        </p>

    </div>

    <script>
        // Bloque principal que se ejecuta SOLO cuando toda la página ha cargado
        window.onload = function() {
            // --- 1. Referencias al DOM ---
            const statusMessage = document.getElementById('statusMessage');
            const toggleButton = document.getElementById('toggleButton');
            const pitchSlider = document.getElementById('pitchSlider');
            const currentPitchSpan = document.getElementById('currentPitch');
            const audioFileInput = document.getElementById('audioFile');

            // --- 2. Variables Globales de la Aplicación ---
            let audioContext;
            let audioBuffer = null;
            let sourceNode = null;
            let processorNode = null; // Reemplaza a pitchShifter
            let isPlaying = false;
            let currentSemitones = 0; // Estado del tono

            // --- 3. Función para mostrar mensajes de estado ---
            function showStatus(message, isError = false) {
                statusMessage.textContent = message;
                statusMessage.className = `text-center text-sm mb-6 h-4 transition-opacity ${isError ? 'text-red-400' : 'text-yellow-300'}`;
            }

            // --- 4. Inicializar el contexto de audio ---
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            } catch (e) {
                console.error("Error al inicializar AudioContext:", e);
                showStatus('Error: Fallo al inicializar el motor de audio del navegador.', true);
                return;
            }

            // --- 5. Implementación del Pitch Shifter (Integrado) ---
            // Usamos un ScriptProcessorNode simple para aplicar un cambio de tono básico.
            function createSimplePitchShifter(context, bufferSize = 4096) {
                const node = context.createScriptProcessor(bufferSize, 1, 1);

                // Variables del algoritmo de cambio de tono
                // El tamaño del buffer debe ser lo suficientemente grande para el rango de pitch shift
                // Ajustamos el buffer para manejar el rango de 4 octavas (-48 a +48)
                const delayBufferLength = bufferSize * 16;
                let inputBuffer = new Float32Array(delayBufferLength);
                let writeIndex = 0;

                node.onaudioprocess = function(event) {
                    const input = event.inputBuffer.getChannelData(0);
                    const output = event.outputBuffer.getChannelData(0);
                    const semitones = currentSemitones;

                    // Factor de cambio de frecuencia
                    const factor = 1 / Math.pow(2, semitones / 12);

                    // Implementación de retraso simple (delay-based pitch shift)
                    for (let i = 0; i < bufferSize; i++) {
                        // 1. Escribir el nuevo dato al buffer de retraso
                        inputBuffer[writeIndex] = input[i];
                        writeIndex = (writeIndex + 1) % inputBuffer.length;

                        // 2. Calcular la posición de lectura (con factor de tono)
                        // Ajustamos el offset para el nuevo rango de 4 octavas
                        let readIndex = writeIndex - Math.floor(bufferSize * 8 * factor);

                        // Asegurarse de que el índice sea positivo y esté dentro del rango del buffer
                        while (readIndex < 0) {
                            readIndex += inputBuffer.length;
                        }
                        while (readIndex >= inputBuffer.length) {
                            readIndex -= inputBuffer.length;
                        }

                        // 3. Obtener la muestra de salida y suavizar (interpolación simple)
                        const sampleIndex = Math.floor(readIndex);
                        const fraction = readIndex - sampleIndex;
                        const nextSampleIndex = (sampleIndex + 1) % inputBuffer.length;

                        // Interpolación lineal
                        const sample = inputBuffer[sampleIndex] * (1 - fraction) +
                                       inputBuffer[nextSampleIndex] * fraction;

                        output[i] = sample;
                    }
                };

                return node;
            }


            // --- MANEJO DE ARCHIVO ---
            audioFileInput.addEventListener('change', (event) => {
                // Si ya está reproduciendo, detenemos antes de cargar otro archivo
                if (isPlaying) {
                    togglePlayback();
                }

                const file = event.target.files[0];
                if (!file) return;

                // 1. Bloqueamos la interfaz y mostramos el estado de carga
                showStatus('Cargando y decodificando audio. Por favor, espere...', false);
                toggleButton.disabled = true;
                toggleButton.textContent = 'Cargando Audio...';
                pitchSlider.disabled = true;

                // 2. Leer el archivo como ArrayBuffer
                const reader = new FileReader();
                reader.onload = () => {
                    const arrayBuffer = reader.result;

                    // 3. Decodificar los datos de audio (esta es la parte lenta)
                    audioContext.decodeAudioData(arrayBuffer,
                        (buffer) => {
                            // --- Éxito en la decodificación ---
                            audioBuffer = buffer;
                            toggleButton.disabled = false;
                            toggleButton.textContent = 'Reproducir Audio';
                            pitchSlider.disabled = false;
                            showStatus('Audio listo. ¡Presiona Reproducir!');
                            updatePitch(pitchSlider.value, false);
                        },
                        (error) => {
                            // --- Error en la decodificación ---
                            console.error('Error al decodificar audio:', error);
                            showStatus('Error al decodificar el archivo. Asegúrate de que sea un formato válido.', true);
                            audioBuffer = null;
                            toggleButton.disabled = true;
                            toggleButton.textContent = 'Cargar Audio Primero';
                        }
                    );
                };

                reader.onerror = (e) => {
                    console.error('Error al leer el archivo:', e);
                    showStatus('Error al leer el archivo. Intenta de nuevo.', true);
                    toggleButton.disabled = true;
                    toggleButton.textContent = 'Cargar Audio Primero';
                };

                reader.readAsArrayBuffer(file);
            });


            // --- CONTROL DE REPRODUCCIÓN ---
            window.togglePlayback = function() {
                // Asegurarse de que el contexto de audio se reanude (necesario en muchos navegadores móviles)
                if (audioContext && audioContext.state === 'suspended') {
                    audioContext.resume();
                }

                if (!audioBuffer) {
                    showStatus('Por favor, carga un archivo de audio primero.', true);
                    return;
                }

                if (isPlaying) {
                    // Detener la reproducción
                    if (sourceNode) {
                        try {
                            sourceNode.stop(audioContext.currentTime + 0.01);
                            sourceNode.disconnect();
                            // Desconectar el ScriptProcessorNode
                            if (processorNode) processorNode.disconnect();
                        } catch (e) {
                            console.warn('Error al detener la fuente:', e);
                        }
                    }
                    isPlaying = false;
                    toggleButton.textContent = 'Reproducir Audio';
                    showStatus('Reproducción detenida.');
                } else {
                    // Iniciar la reproducción

                    // 1. Crear un NUEVO SourceNode y el ScriptProcessorNode (si no existe)
                    sourceNode = audioContext.createBufferSource();
                    sourceNode.buffer = audioBuffer;

                    if (!processorNode) {
                        processorNode = createSimplePitchShifter(audioContext);
                    }

                    // 2. CONEXIÓN DEL GRAFO DE AUDIO: Fuente -> Procesador -> Destino
                    sourceNode.connect(processorNode);
                    processorNode.connect(audioContext.destination);

                    // 3. Aplicar el valor actual (se usa internamente en el nodo)
                    // (Ya se actualiza en la función updatePitch)

                    // 4. Iniciar
                    sourceNode.start(0);
                    isPlaying = true;
                    toggleButton.textContent = 'Detener Reproducción';
                    showStatus('Reproduciendo con Pitch Shifter...');

                    // Manejar el evento cuando el audio termina por sí solo
                    sourceNode.onended = () => {
                        // Solo si el audio terminó por sí solo y no por un stop manual
                        if (isPlaying) {
                            isPlaying = false;
                            toggleButton.textContent = 'Reproducir Audio';
                            showStatus('Reproducción finalizada.');
                            sourceNode = null;
                            if (processorNode) processorNode.disconnect();
                        }
                    };
                }
            }

            // --- CONTROL DEL TONO/FRECUENCIA ---
            window.updatePitch = function(semitoneValue, applyImmediately = true) {
                const semitones = parseFloat(semitoneValue); // Usar parseFloat para manejar el step 0.1
                currentSemitones = semitones; // Actualiza la variable global que usa el processorNode

                // Actualizar la etiqueta del UI con un decimal
                currentPitchSpan.textContent = `${semitones.toFixed(1)} Semitonos (${semitones === 0 ? 'Original' : semitones > 0 ? 'Agudo' : 'Grave'})`;

                if (applyImmediately) {
                    showStatus(`Tono ajustado a ${semitones.toFixed(1)} semitonos.`);
                }
            }

            // Inicializar el pitch al cargar para mostrar 0.0
            updatePitch(0, false);
        }; // Fin de window.onload

    </script>
</body>
</html>
